---
layout: post
title: "http"
date:   2020-12-18
tags: [note]
comments: true
toc: true
author: zhangjialun
---
详解http1.0 http1.1 http2.0

<!-- more -->
## 开始

作为一名前端开发er,http是我们知识图谱里面不可获取的知识。

### http发展史

![http发展史](https://zhangjialun555.github.io/images/http/WechatIMG68.png)

- HTTP/0.9 - 单行协议
  HTTP与1990年问世，那时候http很简单只支持GET方法，没有首部，只能获取纯文本。
- HTTP/1.0 - 搭建协议的框架
  1996年，http被正式作为标准公布，1.0版本增加了首部，状态码，权限，缓存，长连接（默认断连接）等搭建了协议的基本框架。
- HTTP/1.1 - 进一步完善
  1997年1.1版本接踵而至，1.1版本默认长连接；强制客户端提供Host首部；管线化；Cache-Control,Etag等缓存相关拓展。

### http1.0和http1.1的区别

#### 缓存处理

在http1.0中，主要使用header里的 `If-Modified-Since`（比较资源最后的更新时间是否一致），`Expries` (资源的过期时间（取决于客户端本地时间）)，来作为缓存判断的标准。
http1.1则引入了更多的缓存控制策略：

- tag:资源的匹配信息
- if-Unmodified-Since:比较资源最后更新的时间是否一致
- if-Match：比较Etag是否一致
- if-None-Match:比较ETag是否不一致

等更多可供选择的缓存头来控制缓存策略。

#### 带宽优化

http.10中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务端却将整个对象送过来了，并且不支持断点续传。

http1.1默认支持断点续传

#### Host头处理

在http1.0中认为每台服务器都绑定唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且他们共享了同一个IP地址。
http1.1的请求消息和相应消息都支持Host头域，且请求消息中如果没有host头域会报告一个错误（400 bad Request。

#### 长连接

在http1.0需要需要使用keep-alive参数来告知服务器要创建一个长连接，而http1.1默认支持长连接，一定程度上弥补了http1.0每次请求都需要创建连接的缺点。

http是基于TCP/IP协议的，创意一个tcp连接是需要经过三次握手四次挥手的。有一定的开销，如果每次通讯都需要穿创建新的连接，对性能有影响。因为需要维持一个长连接，可以用这个长连接来发送多个请求。

HTTP1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个tcp连接上可以处理多个http请求和相应，减少了建立和关闭连接的消耗和延迟。

#### 错误通知管理

在http1.1中新增了24种错误状态相应码，如409（conflict）表示请求的资源与资源的与资源的当前状态发生冲突。410（gone）表示服务器上的某个资源被永久性删除。

#### 新增请求方式

PUT:请求服务器存储一个资源
DELETE:请求服务请删除标示的资源
OPTIONS:请求查询服务器的性能，或者查询与资源相关的选项和需求
CONNECT:保留请求以供将来使用
TRACE:请求服务器会送收到的请求消息，主要用于测试或诊断

### HTTP2.0与HTTP1.X的区别

#### 二进制分帧

http1.x的解析是基于文本的。基于文本协议的格式解析存在天然缺陷，文本的表现形式多样，要做到健壮性必然要考虑多场景，二进制格式则不同，只认识0和1。基于这种考虑http2.0的协议解析决定使用二进格式，实现方便且健壮。

http2.0在应用层（HTTP2.0）和传输层（tcp/udp）之间增加一个二进制分帧层。在不改动http1.x的语义、方法、状态码、URL以及首部字段的情况下，解决http1.1的性能限制，改进传输性能，实现低延迟和高吞吐量。在二进制分帧层中，http2.0会将所有传输得到信息分割为更小的消息和帧（frame）,并对他们采用二进制格式的编码，其中HTTP1.X的首部信息会被封装到HEADER frame,而相对request body则封装到data frame里面。

- 帧：http2.0数据通信的最小单位消息：指http2.0中逻辑上的http消息。例如请求和相应等，消息由一个或多个帧组成。
- 流：存在于连接中的一个虚拟通道，流可以承载双向消息，每个流都有一个唯一的整数ID。

#### 多路复用

多路复用允许同时通过单一的http2.0连接发送多重请求-相应消息。即是连接共享，提高了连接的利用率，将低延迟。即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接可以由多个request，每个连接的request可以随机混杂在一起，接收方可以动过ID将request再归属到各自不同的服务端请求里面。

在http1.1协议中浏览器客户端在同一时间，针对同一域名下的请求有一定的数量限制。超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源CDN域名的原因之一。

当然在http1.1也可以多建立几个TCP连接，来支持处理更多并发请求，但是创建TCP连接本身也是有开销的。

TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦传送成功，则满满加大传输速度。因此对应瞬时并发的连接，服务器的相应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。

HTTP2.0可以很容易的去实现多流并行而且不依赖建立多个TCP连接，同个域名只需要占用一个TCP连接，消除了因多个TCP连接而带来的延时和内存消耗。HTTP2.0把http协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行的在同一个TCP连接上双向交换信息。

#### header 压缩

http1.x的header带有大量信息，而且每次都要重复发送消息，HTTP2.0使用HPACK算法对header的数据进行压缩，减少要传输的header的大小，通讯双方各自cache一份header fields表，差量更新header，即避免了重复的header传输，又减少了需要传输的大小。

header采取的压缩策略：

- HTTP2.0在客户端和服务端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和相应发送；
- 首部表在HTTP2.0的连接存续期内始终存在，由客户端和服务端共同渐进更新；
- 每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的键值对。

#### 服务端推送

服务端推送是一种在客户端强求之前发送数据的机制。

服务端可以在发送页面的html时主动推送其他资源，而不用动浏览器解析到相应的位置，发送请求再相应。例如服务端可以主动把js和css文件推送给客户端，而不需要客户端解析html时再发送这些请求。

服务端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。

