---
layout: post
title: "Promise"
date:   2020-11-15
tags: [note]
comments: true
author: zhangjialun
---
promise 日常理解

<!-- more -->
## Promise作用

- 解决并发问题（同步多个异步方法的执行结果）
- 链式调用问题（先获取手机，再通过手机获取电脑的问题）解决多个回调嵌套的问题 ```

### Promise简介

#### Promise是一个类

- 每次new一个Promise都需传递一个立即执行的执行器

- 执行器中有两个参数 resolve reject

- Promise默认有三个状态 pendind(等待) resolve(成功) reject(失败)

- 一旦成功不能失败，一旦失败不能成功

- 每个Promise都有一个then方法

#### Promise的链式调用

- 普通值表示不是Promise也不是错误（then回调中返回的）会走下一个then的成功

- 如果返回一个Promise,那么这个Promise会执行，并且采用他的状态

- 抛出错误走then失败的方法

- 返回一个新的Promise来实现链式调用

### Promise基础用法实例

```
let p = new Promise((resolve, reject) => {
  resolve("success");
  throw new Error("失败"); //如果抛出异常也会执行成功
});
p.then(
  (data) => {
    console.log(data);
  },
  (err) => {
    console.log(err);
  }
);

let p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("resolve在then之后执行"); // 发布
  }, 1e3);
});
// 订阅多个then方法
p2.then(
  (data) => {
    console.log(data);
  },
  (err) => {
    console.log(err);
  }
);
p2.then(
  (data) => {
    console.log(data);
  },
  (err) => {
    console.log(err);
  }
);
```

### Promise基础用法的实现

```
const PENDING = "PENGDING";
const FULFILLED = "FULFILLED";
const REJECTED = "REJECTED";
console.log("---------------引入成功");
class Promise {
  constructor(executor) {
    this.value = undefined;
    this.reason = undefined;
    this.status = PENDING;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks = [];
    let resolve = value => {
      if (this.status === PENDING) {
        this.value = value;
        this.status = FULFILLED;
        this.onResolvedCallbacks.forEach(fn => fn()); // 发布 有可能resolve在then的后边执行，此时先将方法存放起来，状态改变为成功时依次执行这些方法（同一个示例订阅了多个then方法）
      }
    };
    let reject = reason => {
      if (this.status === PENDING) {
        this.value = reason;
        this.status = REJECTED;
        this.onRejectedCallbacks.forEach(fn => fn());
      }
    };
    // 创建promise executor(执行器)会立即执行
    // 这里可能会发生异常
    try {
      executor(resolve, reject);
    } catch (e) {
      reject(e);
    }
  }
then(onFulfilled, onRejected) {
    if (this.status === FULFILLED) {
      onFulfilled(this.value);
    }
    if (this.status === REJECTED) {
      onRejected(this.reason);
    }
    if (this.status === PENDING) {
      this.onResolvedCallbacks.push(() => {
        // 外面在包一层函数 可以在这里再做一些其他的事 todo...
        onFulfilled(this.value);
      });
      this.onRejectedCallbacks.push(() => {
        // 外面在包一层函数 可以在这里再做一些其他的事 todo...
        onRejected(this.reason);
      });
    }
  }
}
// 导出当前类 commonjs定义的方式
module.exports = Promise;
```
